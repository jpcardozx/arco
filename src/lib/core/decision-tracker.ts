/**
 * ARCO Decision Quality Tracker
 * Measures impact of context system on decision-making and business outcomes
 */

import fs from 'fs/promises'
import path from 'path'

interface DecisionRecord {
  id: string
  date: string
  decision: string
  category: 'technical' | 'business' | 'operational' | 'strategic'
  contextUsed: boolean
  contextQuery?: string
  confidenceScore: number // 1-10
  timeToDecision: number // minutes
  businessImpact: 'high' | 'medium' | 'low'
  reasoning: string
  outcome?: string
  outcomeDate?: string
}

interface WeeklyReport {
  period: string
  totalDecisions: number
  decisionsWithContext: number
  averageConfidence: number
  averageTimeToDecision: number
  businessImpactSummary: {
    high: number
    medium: number  
    low: number
  }
  keyInsights: string[]
  recommendations: string[]
}

export class DecisionTracker {
  private decisionsFile: string

  constructor() {
    this.decisionsFile = path.join(process.cwd(), 'context', 'decisions.json')
  }

  /**
   * Record a new decision
   */
  async recordDecision(decision: Omit<DecisionRecord, 'id' | 'date'>): Promise<void> {
    const decisions = await this.loadDecisions()
    
    const newDecision: DecisionRecord = {
      id: `decision-${Date.now()}`,
      date: new Date().toISOString(),
      ...decision
    }
    
    decisions.push(newDecision)
    await this.saveDecisions(decisions)
    
    console.log('✅ Decision recorded:', newDecision.decision)
  }

  /**
   * Update decision outcome
   */
  async updateOutcome(decisionId: string, outcome: string): Promise<void> {
    const decisions = await this.loadDecisions()
    const decision = decisions.find(d => d.id === decisionId)
    
    if (decision) {
      decision.outcome = outcome
      decision.outcomeDate = new Date().toISOString()
      await this.saveDecisions(decisions)
      console.log('✅ Outcome updated for:', decision.decision)
    }
  }

  /**
   * Generate weekly impact report
   */
  async generateWeeklyReport(): Promise<WeeklyReport> {
    const decisions = await this.loadDecisions()
    const oneWeekAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000)
    const recentDecisions = decisions.filter(d => new Date(d.date) >= oneWeekAgo)
    
    const decisionsWithContext = recentDecisions.filter(d => d.contextUsed)
    const averageConfidence = recentDecisions.length > 0 
      ? recentDecisions.reduce((sum, d) => sum + d.confidenceScore, 0) / recentDecisions.length
      : 0
    const averageTime = recentDecisions.length > 0
      ? recentDecisions.reduce((sum, d) => sum + d.timeToDecision, 0) / recentDecisions.length  
      : 0

    const businessImpactSummary = {
      high: recentDecisions.filter(d => d.businessImpact === 'high').length,
      medium: recentDecisions.filter(d => d.businessImpact === 'medium').length,
      low: recentDecisions.filter(d => d.businessImpact === 'low').length
    }

    const report: WeeklyReport = {
      period: `${oneWeekAgo.toLocaleDateString()} - ${new Date().toLocaleDateString()}`,
      totalDecisions: recentDecisions.length,
      decisionsWithContext: decisionsWithContext.length,
      averageConfidence: Math.round(averageConfidence * 10) / 10,
      averageTimeToDecision: Math.round(averageTime),
      businessImpactSummary,
      keyInsights: this.generateInsights(recentDecisions, decisionsWithContext),
      recommendations: this.generateRecommendations(recentDecisions, decisionsWithContext)
    }

    return report
  }

  /**
   * Export report as markdown
   */
  async exportWeeklyReport(): Promise<string> {
    const report = await this.generateWeeklyReport()
    
    return `# ARCO Decision Quality Report
**Period:** ${report.period}  
**Generated:** ${new Date().toLocaleDateString()}

## Summary Metrics
- **Total Decisions:** ${report.totalDecisions}
- **Decisions with Context:** ${report.decisionsWithContext} (${report.totalDecisions > 0 ? Math.round((report.decisionsWithContext / report.totalDecisions) * 100) : 0}%)
- **Average Confidence:** ${report.averageConfidence}/10
- **Average Decision Time:** ${report.averageTimeToDecision} minutes

## Business Impact Distribution
- **High Impact:** ${report.businessImpactSummary.high} decisions
- **Medium Impact:** ${report.businessImpactSummary.medium} decisions  
- **Low Impact:** ${report.businessImpactSummary.low} decisions

## Key Insights
${report.keyInsights.map(insight => `- ${insight}`).join('\n')}

## Recommendations
${report.recommendations.map(rec => `- ${rec}`).join('\n')}

## Context System Effectiveness
${this.assessContextEffectiveness(report)}

---
*Generated by ARCO Decision Tracker*
`
  }

  /**
   * Interactive decision recording CLI
   */
  async recordDecisionInteractive(): Promise<void> {
    console.log('\n📋 ARCO Decision Recorder')
    console.log('=' .repeat(40))
    
    // This would be replaced with actual CLI prompts in production
    const sampleDecision: Omit<DecisionRecord, 'id' | 'date'> = {
      decision: "Use context system for all technical decisions",
      category: "operational",
      contextUsed: true,
      contextQuery: "How should I optimize my decision-making process?",
      confidenceScore: 9,
      timeToDecision: 5,
      businessImpact: "medium",
      reasoning: "Context system provides relevant information quickly, improves decision quality"
    }
    
    await this.recordDecision(sampleDecision)
    console.log('📊 Decision recorded! Use weekly report to track impact.')
  }

  private async loadDecisions(): Promise<DecisionRecord[]> {
    try {
      const content = await fs.readFile(this.decisionsFile, 'utf-8')
      return JSON.parse(content)
    } catch (error) {
      // File doesn't exist yet
      await fs.mkdir(path.dirname(this.decisionsFile), { recursive: true })
      return []
    }
  }

  private async saveDecisions(decisions: DecisionRecord[]): Promise<void> {
    await fs.mkdir(path.dirname(this.decisionsFile), { recursive: true })
    await fs.writeFile(this.decisionsFile, JSON.stringify(decisions, null, 2))
  }

  private generateInsights(allDecisions: DecisionRecord[], contextDecisions: DecisionRecord[]): string[] {
    const insights: string[] = []
    
    if (contextDecisions.length > 0) {
      const contextConfidence = contextDecisions.reduce((sum, d) => sum + d.confidenceScore, 0) / contextDecisions.length
      const noContextDecisions = allDecisions.filter(d => !d.contextUsed)
      const noContextConfidence = noContextDecisions.length > 0 
        ? noContextDecisions.reduce((sum, d) => sum + d.confidenceScore, 0) / noContextDecisions.length
        : 0

      if (noContextDecisions.length > 0) {
        const confidenceDiff = contextConfidence - noContextConfidence
        insights.push(`Decisions with context scored ${confidenceDiff.toFixed(1)} points higher in confidence`)
      }
      
      const highImpactWithContext = contextDecisions.filter(d => d.businessImpact === 'high').length
      const contextUsageRate = (contextDecisions.length / allDecisions.length) * 100
      
      insights.push(`${contextUsageRate.toFixed(1)}% of decisions used context system`)
      insights.push(`${highImpactWithContext} high-impact decisions benefited from context`)
    }
    
    if (insights.length === 0) {
      insights.push('Insufficient data for insights - continue tracking decisions')
    }
    
    return insights
  }

  private generateRecommendations(allDecisions: DecisionRecord[], contextDecisions: DecisionRecord[]): string[] {
    const recommendations: string[] = []
    
    const contextUsageRate = allDecisions.length > 0 
      ? (contextDecisions.length / allDecisions.length) * 100 
      : 0
    
    if (contextUsageRate < 50) {
      recommendations.push('Increase context system usage - aim for 70%+ of decisions')
    }
    
    if (contextUsageRate > 70) {
      recommendations.push('Context system well-adopted - focus on measuring business outcomes')
    }
    
    const avgConfidence = allDecisions.length > 0
      ? allDecisions.reduce((sum, d) => sum + d.confidenceScore, 0) / allDecisions.length
      : 0
    
    if (avgConfidence < 7) {
      recommendations.push('Low confidence scores - improve context quality or decision process')
    }
    
    const highImpactDecisions = allDecisions.filter(d => d.businessImpact === 'high').length
    if (highImpactDecisions < allDecisions.length * 0.3) {
      recommendations.push('Focus on higher-impact decisions - current mix too operational')
    }
    
    return recommendations
  }

  private assessContextEffectiveness(report: WeeklyReport): string {
    const contextUsageRate = report.totalDecisions > 0 
      ? (report.decisionsWithContext / report.totalDecisions) * 100 
      : 0
    
    if (contextUsageRate > 70 && report.averageConfidence > 7.5) {
      return '✅ **EFFECTIVE** - Context system showing strong adoption and confidence scores'
    } else if (contextUsageRate > 50 && report.averageConfidence > 6.5) {
      return '⚠️ **PROMISING** - Good adoption, monitor confidence and business impact'
    } else if (contextUsageRate > 30) {
      return '📊 **DEVELOPING** - Building adoption, focus on improving relevance'
    } else {
      return '🔍 **EARLY STAGE** - Low adoption, investigate barriers to usage'
    }
  }
}

// CLI interface
if (require.main === module) {
  const tracker = new DecisionTracker()
  const command = process.argv[2]
  
  if (command === 'record') {
    tracker.recordDecisionInteractive()
  } else if (command === 'report') {
    tracker.exportWeeklyReport().then(report => {
      console.log(report)
      
      // Save report
      const reportPath = path.join(process.cwd(), 'reports', `decision-report-${new Date().toISOString().split('T')[0]}.md`)
      fs.mkdir(path.dirname(reportPath), { recursive: true })
        .then(() => fs.writeFile(reportPath, report))
        .then(() => console.log(`\n📄 Report saved to: ${reportPath}`))
    })
  } else {
    console.log('Usage:')
    console.log('npm run decision:record  # Record a new decision')
    console.log('npm run decision:report  # Generate weekly report')
  }
}
